---
layout: posts
title: CSP 题解
tags: cpp
---

# CSP 题解

此页面均非最终代码，与CSP最终提交代码有差别

## 1.candy

> 红太阳幼儿园有 n 个小朋友，你是其中之一。保证 n ≥2。
有一天你在幼儿园的后花园里发现无穷多颗糖果，你打算拿一些糖果回去分给幼儿
园的小朋友们。
由于你只是个平平无奇的幼儿园小朋友，所以你的体力有限，至多只能拿 R 块糖
回去。
但是拿的太少不够分的，所以你至少要拿 L 块糖回去。保证 n ≤L ≤R。
也就是说，如果你拿了 k 块糖，那么你需要保证 L ≤k ≤R。
如果你拿了 k 块糖，你将把这 k 块糖放到篮子里，并要求大家按照如下方案分糖
果：只要篮子里有 .不 .少 .于 n 块糖果，幼儿园的所有 n 个小朋友（包括你自己）都从篮子
中拿走 .恰 .好一块糖，直到篮子里的糖数量 .少 .于 n 块。此时篮子里剩余的糖果均归你所有
——这些糖果是 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励。
作为幼儿园高质量小朋友，你希望让 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励的糖果数量（ .而 .不 .是 .你 .最
.后 .获 .得 .的 .总 .糖 .果 .数 .量！）尽可能多；因此你需要写一个程序，依次输入 n, L, R，并输出
出你最多能获得多少 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励的糖果数量。

（好家伙，考试的时候甚至有人唱高质量歌曲）

简化题目：

> 红太阳幼儿园有 n 个小朋友。保证 n ≥2。无穷多颗糖果。至多只能拿 R 块糖回去。你至少要拿 L 块糖回去。保证 n ≤L ≤R。如果你拿了 k 块糖，那么你需要保证 L ≤k ≤R。
如果你拿了 k 块糖，你将把这 k 块糖放到篮子里，并要求大家按照如下方案分糖果：只要篮子里有 .不 .少 .于 n 块糖果，幼儿园的所有 n 个小朋友（包括你自己）都从篮子
中拿走 .恰 .好一块糖，直到篮子里的糖数量 .少 .于 n 块。此时篮子里剩余的糖果均归你所有
——这些糖果是 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励。
作为幼儿园高质量小朋友，你希望让 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励的糖果数量（ .而 .不 .是 .你 .最
.后 .获 .得 .的 .总 .糖 .果 .数 .量！）尽可能多；因此你需要写一个程序，依次输入 n, L, R，并输出
出你最多能获得多少 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励的糖果数量。

嗯，简单明了，可以直接for循环l到r，算出奖励找最大。
需要注意算奖励可以直接%

``` javascript
#include<iostream>
using namespace std;
int main(){
	int n, l, r;
	cin >> n >> l >> r;
	int maxjl = -1;
	for(int k = l; k <= r; k++){
		int jl = k % n;
		if(jl > maxjl){
			maxjl = jl;
		}
	}
	cout << maxjl;
	return 0;
}
```

哈哈解决（我花了大概一个小时【笑哭】）

## 2.sort

> 为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H 老师留下了这么一道家庭作业：
H 老师给了一个长度为 n 的数组 a，数组下标从 1 开始，并且数组中的所有元素均
为非负整数。小 Z 需要支持在数组 a 上的 Q 次操作，操作共两种，参数分别如下：
1 x v : 这是第一种操作，会将 a 的第 x 个元素，也就是 ax 的值，修改为 v。保证
1 ≤x ≤n, 1 ≤v ≤109。 .注 .意 .这 .种 .操 .作 .会 .改 .变 .数 .组 .的 .元 .素， .修 .改 .得 .到 .的 .数 .组 .会 .被 .保 .留，
.也 .会 .影 .响 .后 .续 .的 .操 .作。
2 x : 这是第二种操作，假设 H 老师按照 .上 .面 .的 .伪 .代 .码对 a 数组进行排序，你需要
告诉 H 老师原来 a 的第 x 个元素，也就是 ax，在排序后的新数组所处的位置。保证
1 ≤x ≤n。.注 .意 .这 .种 .操 .作 .不 .会 .改 .变 .数 .组 .的 .元 .素，.排 .序 .后 .的 .数 .组 .不 .会 .被 .保 .留，.也 .不 .会 .影 .响
.后 .续 .的 .操 .作。H 老师不喜欢过多的修改，所以他保证类型 1 的操作次数不超过 5000。
小 Z 没有学过计算机竞赛，因此小 Z 并不会做这道题。他找到了你来帮助他解决
这个问题

其实是冒泡啦，题目给出的伪代码

``` javascript
for (int i = 1; i <= n; i++)
	for (int j = i; j>=2; j‐‐)
		if ( a[j] < a[j‐1] ){
		int t = a[j‐1];
		a[j‐1] = a[j];
		a[j] = t;
}
```

复杂点，写的多

``` javascript
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
	freopen("in.in", "r", stdin);
	int n, q;
	cin >> n >> q;
	int a[n+1];
	for(int i = 1; i <= n; i++){
		cin >> a[i];
	}
	int c[q+1], x[q+1], v[q+1];
	for(int i = 1; i <= q; i++){
		cin >> c[i];
		if(c[i] == 1){
			cin >> x[i] >> v[i];
		}
		else{
			cin >> x[i];
		}
	}
	for(int i = 1; i <= q; i++){
		if(c[i] == 1){
			a[x[i]] = v[i];
		}
		else{
			int lin[n];
			for(int i = 1; i <= n; i++){
				lin[i] = a[i];
			}
			int pos = x[i];
			for(int c = 1; c <= n; c++){
				for(int b = c; b >= 2; b--){
					if (lin[b] < lin[b-1]){
						int t = lin[b];
						lin[b] = lin[b-1];
						lin[b-1] = t;
						if(pos == b){
							pos --;
						}
						else if(pos == b - 1){
							pos ++;
						}
					}
				}
			}
			cout << pos << endl;
		}
	}
	return 0;
}
```

## 3.network

没写出来

## 4.fruit

哈哈

> 小熊的水果店里摆放着一排 n 个水果。每个水果只可能是苹果或桔子，从左到右依
次用正整数 1、2、3、......、n 编号。连续排在一起的同一种水果称为一个“块”。小熊
要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水
果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮
后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹果
“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果

看起来很复杂，实际上记录下

