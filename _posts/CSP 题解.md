---
layout: posts
title: 2021-10-24-csp.md
tags: cpp
---

# CSP 题解

此页面均非最终代码，与CSP最终提交代码有差别

## 1.candy

> 红太阳幼儿园有 n 个小朋友，你是其中之一。保证 n ≥2。
有一天你在幼儿园的后花园里发现无穷多颗糖果，你打算拿一些糖果回去分给幼儿
园的小朋友们。
由于你只是个平平无奇的幼儿园小朋友，所以你的体力有限，至多只能拿 R 块糖
回去。
但是拿的太少不够分的，所以你至少要拿 L 块糖回去。保证 n ≤L ≤R。
也就是说，如果你拿了 k 块糖，那么你需要保证 L ≤k ≤R。
如果你拿了 k 块糖，你将把这 k 块糖放到篮子里，并要求大家按照如下方案分糖
果：只要篮子里有 .不 .少 .于 n 块糖果，幼儿园的所有 n 个小朋友（包括你自己）都从篮子
中拿走 .恰 .好一块糖，直到篮子里的糖数量 .少 .于 n 块。此时篮子里剩余的糖果均归你所有
——这些糖果是 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励。
作为幼儿园高质量小朋友，你希望让 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励的糖果数量（ .而 .不 .是 .你 .最
.后 .获 .得 .的 .总 .糖 .果 .数 .量！）尽可能多；因此你需要写一个程序，依次输入 n, L, R，并输出
出你最多能获得多少 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励的糖果数量。

（好家伙，考试的时候甚至有人唱高质量歌曲）

简化题目：

> 红太阳幼儿园有 n 个小朋友。保证 n ≥2。无穷多颗糖果。至多只能拿 R 块糖回去。你至少要拿 L 块糖回去。保证 n ≤L ≤R。如果你拿了 k 块糖，那么你需要保证 L ≤k ≤R。
如果你拿了 k 块糖，你将把这 k 块糖放到篮子里，并要求大家按照如下方案分糖果：只要篮子里有 .不 .少 .于 n 块糖果，幼儿园的所有 n 个小朋友（包括你自己）都从篮子
中拿走 .恰 .好一块糖，直到篮子里的糖数量 .少 .于 n 块。此时篮子里剩余的糖果均归你所有
——这些糖果是 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励。
作为幼儿园高质量小朋友，你希望让 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励的糖果数量（ .而 .不 .是 .你 .最
.后 .获 .得 .的 .总 .糖 .果 .数 .量！）尽可能多；因此你需要写一个程序，依次输入 n, L, R，并输出
出你最多能获得多少 .作 .为 .你 .搬 .糖 .果 .的 .奖 .励的糖果数量。

嗯，简单明了，可以直接for循环l到r，算出奖励找最大。
需要注意算奖励可以直接%

``` c++
#include<iostream>
using namespace std;
int main(){
	int n, l, r;
	cin >> n >> l >> r;
	int maxjl = -1;
	for(int k = l; k <= r; k++){
		int jl = k % n;
		if(jl > maxjl){
			maxjl = jl;
		}
	}
	cout << maxjl;
	return 0;
}
```

哈哈解决（我花了大概一个小时【笑哭】）

## 2.sort

> 为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H 老师留下了这么一道家庭作业：
H 老师给了一个长度为 n 的数组 a，数组下标从 1 开始，并且数组中的所有元素均
为非负整数。小 Z 需要支持在数组 a 上的 Q 次操作，操作共两种，参数分别如下：
1 x v : 这是第一种操作，会将 a 的第 x 个元素，也就是 ax 的值，修改为 v。保证
1 ≤x ≤n, 1 ≤v ≤109。 .注 .意 .这 .种 .操 .作 .会 .改 .变 .数 .组 .的 .元 .素， .修 .改 .得 .到 .的 .数 .组 .会 .被 .保 .留，
.也 .会 .影 .响 .后 .续 .的 .操 .作。
2 x : 这是第二种操作，假设 H 老师按照 .上 .面 .的 .伪 .代 .码对 a 数组进行排序，你需要
告诉 H 老师原来 a 的第 x 个元素，也就是 ax，在排序后的新数组所处的位置。保证
1 ≤x ≤n。.注 .意 .这 .种 .操 .作 .不 .会 .改 .变 .数 .组 .的 .元 .素，.排 .序 .后 .的 .数 .组 .不 .会 .被 .保 .留，.也 .不 .会 .影 .响
.后 .续 .的 .操 .作。H 老师不喜欢过多的修改，所以他保证类型 1 的操作次数不超过 5000。
小 Z 没有学过计算机竞赛，因此小 Z 并不会做这道题。他找到了你来帮助他解决
这个问题

题目给出的伪代码

``` javascript
for (int i = 1; i <= n; i++)
	for (int j = i; j>=2; j‐‐)
		if ( a[j] < a[j‐1] ){
		int t = a[j‐1];
		a[j‐1] = a[j];
		a[j] = t;
}
```
（这难道不是冒泡？？？）

复杂点，写的多

``` c++
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
	freopen("in.in", "r", stdin);
	int n, q;
	cin >> n >> q;
	int a[n+1];
	for(int i = 1; i <= n; i++){  //输入数组
		cin >> a[i];
	}
	int c[q+1], x[q+1], v[q+1];
	for(int i = 1; i <= q; i++){  //输入操作，保存在数组里
		cin >> c[i];
		if(c[i] == 1){
			cin >> x[i] >> v[i];
		}
		else{
			cin >> x[i];
		}
	}
	for(int i = 1; i <= q; i++){
		if(c[i] == 1){  //操作1
			a[x[i]] = v[i];
		}
		else{  //操作2
			int lin[n];  //定义临时数组
			for(int i = 1; i <= n; i++){  //数组lin与a同步
				lin[i] = a[i];
			}
			int pos = x[i]; //定义pos，表示a[x]的位置
			for(int c = 1; c <= n; c++){  //冒泡排序
				for(int b = c; b >= 2; b--){
					if (lin[b] < lin[b-1]){
						int t = lin[b];
						lin[b] = lin[b-1];
						lin[b-1] = t;
						//冒泡排序的交换会将lin[b]和lin[b-1]交换，位置随之改变
						if(pos == b){
							//b和b-1交换，如果pos在右边，交换完会向左移动一位
							pos --;
						}
						else if(pos == b - 1){
							//b和b-1交换，如果pos在左边，交换完会向右移动一位
							pos ++;
						}
					}
				}
			}
			cout << pos << endl;
		}
	}
	return 0;
}
```

## 3.network

没写出来：（

## 4.fruit

哈哈

> 小熊的水果店里摆放着一排 n 个水果。每个水果只可能是苹果或桔子，从左到右依
次用正整数 1、2、3、......、n 编号。连续排在一起的同一种水果称为一个“块”。小熊
要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水
果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮
后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹果
“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果

看起来很复杂，实际上记录下上一次拿走的水果就很简单了
（出题应该是想让我们用回溯深搜【笑哭】）

``` c++
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int main() {
	freopen("in.in", "r", stdin);
	int n;
	cin >> n;
	int fruit[n + 1];
	for (int i = 1; i <= n; i++) {  //输入水果，注意下标从1开始！（后面有用）
		cin >> fruit[i];
	}
	int fruitLeft = n;  //剩下的水果数量
	int loopCount = 0;  //拿水果次数
	vector<int> basket[100086];  //篮子，可以不用动态数组，只是还需要记录此篮子的第几个水果（vector可以套vector吗？）
	while (fruitLeft) {  //当还有水果的时候
		int last = fruit[0];  //上一个拿的水果，定义fruit[0]是因为没有0输入，所以是一个很奇怪的数
		//last的定义一定要放在while里面！一会讲
		for (int i = 1; i <= n; i++) {  //遍历水果
			if (fruit[i] != last && fruit[i] != 3) {  //如果此水果与上一个拿的水果不同且此处有水果
				last = fruit[i];  //此处的水果类型（类型！不是位置）给last
				//last赋值要在标记水果空之前，要不然last就是3了
				fruit[i] = 3;  //将此处水果标记为空（随便一个数字，不是0和1就行）
				basket[loopCount].push_back(i);  //这个水果位置（位置！因为题目要求输出位置）推到动态数组里
				fruitLeft--;  //剩下的水果减一
			}
		}
		loopCount++;  //不管有没有拿走水果，每次while循环次数+1
	}
	for (int i = 0; i < loopCount; i++) {  //普通的输出
		int len = basket[i].size();
		sort(basket[i].begin(), basket[i].end());
		for (int j = 0; j < len; j++) {
			cout << basket[i][j] << ' ';
		}
		cout << endl;
	}
	return 0;
}
```

其实还可以，稍微讲解一下

while和for保证了一定拿完全部水果才跳出

last避免了比对fruit[i]和fruit[i-1]时出现其中一个水果位是空而需要继续往回找的情况

为什么last定义一定放在while里